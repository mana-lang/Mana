<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Mana Language Design]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Mana Language Design</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 04 Sep 2025 00:45:08 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 04 Sep 2025 00:45:07 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Enumerations]]></title><description><![CDATA[Mana provides two means of creating enumerations; enums and variants.Mana's enums, like many other languages, offer a simple means of creating labeled values. However, they can do a lot more than that.If you're familiar with C++ enums, that is how Mana enums work in their most basic form.enum Colour { Red // 0 Green // 1 Blue // 2
} data colour = Colour.Red // you can specify what the underlying type of an enum is
enum Animal : u8 { Cat = 2 // enums will count up from the latest value Dog // 3 Lizard // 4
} data animal = Cat // won't compile
Error
Attempted to assign unknown value Cat to data animal. Did you mean Animal.Cat?
Much like in C++, enums in Mana are scoped and can not be implicitly converted to their underlying type by default.Mana also offers the ability to extend an enum by appending new labels to it. To make an enum extensible, you must annotate it with the mut keyword.You may only append labels to an extensible enum from another enum. If you wish to add single values, this is possible by creating an anonymous enum inline. That label will then be parented to the enum it's being appended to. mut enum Dog { Terrier Bulldog Spaniel
} // in another file
enum Dog += enum { Malamute } // or entire sets
enum Dog += enum { BassetHound, Beagle, } // it is not allowed to remove labels of the same parent
enum Dog -= Dog.Beagle
Error
Attempted to remove label Malamute from enum Dog, but Dog is the parent of Malamute
You can also append from named enums.mut enum Weapon { Glock Katana Shoe
} // constant enums may still be appended to mut enums
enum MeleeWeapon { Zweihander Halberd Khopesh Flail
} // append 'MeleeWeapon' labels to 'Weapon'
enum Weapon += enum MeleeWeapon // these labels will be treated as though they are part of 'Weapon'
data flail = Weapon.Flail // 'MeleeWeapon' is still considered its own valid enum
data melee_flail = MeleeWeapon.Flail // enums can easily be serialized to strings
std.println("{1}: {2}", enum.to_string(flail), enum.underlying(flail))
std.print("{1}: {2}", enum.to_string(melee_flail), enum.underlying(melee_flail))
Output
Weapon.Flail: 6
MeleeWeapon.Flail: 3
You can remove labels whose original parent differs from the enum they are appended to.// continuing from before... enum Weapon -= MeleeWeapon.Zweihander // this label is no longer a part of 'Weapon'
data big_sword = Weapon.Zweihander // error, won't compile // other values still remain a part of it
data long_reach = Weapon.Khopesh // unless you remove the entire enum
enum Weapon -= enum MeleeWeapon
Note
Appends made in global scope cannot be removed.
It is either a compile error or undefined behaviour to use an enum after its label has been removed, depending on the circumstance. However, enum appends are scope-bound; they automatically get removed at the end of the scope where they were added.// continuing from before... enum Weapon += MeleeWeapon.Khopesh
data sword = Weapon.Khopesh // compile error, 'Weapon.Khopesh' is still in use
enum Weapon -= MeleeWeapon.Khopesh // -----
// another example
{ enum Weapon += MeleeWeapon.Khopesh
}
// compile error, enum 'Weapon' has no label 'Khopesh'
data sword = Weapon.Khopesh // -----
enum Weapon += MeleeWeapon.Khopesh { data sword = Weapon.Khopesh // do something with `sword`
} enum Weapon -= MeleeWeapon.Khopesh // ok
Warning
While it is fine to append to an enum, it is generally discouraged to explicitly remove from it, as that may lead to unexpected bugs. It is better to allow removal to happen automatically.
To override the default behaviour of enums, such as changing their enumeration values, you must explicitly specify their underlying type. This type must be an integral type, such as i32, but cannot be a bool, even though booleans are technically integral types.// the following enum declaration won't compile
enum Unspecified { A = 10 B = 20
} // but now it will
enum Specified : u8 { A = 10 B = 20
}
By default, each next label will increase the previous label's value by 1. However, this behaviour can be overridden by specifying at least two label values explicitly. Mana will then follow the pattern described by the programmer until it encounters another set of two explicit values, or the enum ends.// normally, enums increment...
enum Countdown : u8 { Ten = 10 Nine = 9 Eight // 8 Seven // 7 Six // etc...
} enum Skip : u8 { Zero Two = 2 Four = 4 Six // 6 Eight // etc...
} // it only considers the last two entries
enum Fibonacci : u8 { A = 1 B = 1 C = 2 D = 3 E = 5 F // 7 G // 9 // not quite fibonacci...
} enum Pattern : u8 { A = 3 B = 6 C // 9 D = 10 E // 13 F = 11 G = 15 H // 19, etc
}
Note
When you manually specify an enum's underlying type, that enum cannot be used as an enum tag, but it can still be extended. The appended labels will follow the same pattern as the base enum
Mana enums can also be used as hierarchical tags. These are called tag enums. This applies only to non-const enums whose underlying type has not been specified.]]></description><link>enumerations.html</link><guid isPermaLink="false">Ecosystem/Syntax/Enumerations.md</guid><pubDate>Wed, 03 Sep 2025 23:53:38 GMT</pubDate></item></channel></rss>