(* Lexer tokens *)

ID         = ^[a-zA-Z_][a-zA-Z0-9_]* ;
INT        = ^[-?0-9]+               ;
FLOAT      = INT.[0-9]+              ;

(*Primitive Datatypes*)
KW_I8     = "i8"         ;
KW_I16    = "i16"        ;
KW_I32    = "i32"        ;
KW_I64    = "i64"        ;
KW_I128   = "i128"       ;

KW_U8     = "u8"         ;
KW_U16    = "u16"        ;
KW_U32    = "u32"        ;
KW_U64    = "u64"        ;
KW_U128   = "u128"       ;

KW_F32    = "f32"        ;
KW_F64    = "f64"        ;

KW_BYTE   = "byte"       ;
KW_CHAR   = "char"       ;
KW_STRING = "string"     ;    

KW_BOOL   = "bool"       ;
KW_VOID   = "void"       ;

(*Declarators*)
KW_DATA     = "data"     ;
KW_FN       = "fn"       ;
KW_MUT      = "mut"      ;
KW_CONST    = "const"    ;
KW_RAW      = "raw"      ;
KW_OVERRIDE = "override" ;

KW_PACK     = "pack"     ;
KW_STRUCT   = "struct"   ;
KW_ENUM     = "enum"     ;
KW_GENERIC  = "generic"  ;

KW_MODULE   = "module"   ;
KW_PUBLIC   = "public"   ;
KW_PRIVATE  = "private"  ;
KW_IMPORT   = "import"   ;
KW_AS       = "as"       ;

(*Control Flow*)
KW_RETURN   = "return"   ;
KW_TRUE     = "true"     ;
KW_FALSE    = "false"    ;
KW_IF       = "if"       ;
KW_ELSE     = "else"     ;
KW_MATCH    = "match"    ;

KW_LOOP     = "loop"     ;
KW_WHILE    = "while"    ;
KW_FOR      = "for"      ;
KW_BREAK    = "break"    ;
KW_SKIP     = "skip"     ;

(*Utility*)
KW_NEWLINE  = "\n"       ;
KW_EOF      = "EOF"      ;
KW_UNKNOWN  = ""         ;


(*Operators*)
OP_PLUS          = '+'         ;
OP_MINUS         = '-'         ;
OP_ASTERISK      = '*'         ;
OP_FWDSLASH      = '/'         ;

OP_COLON         = ':'         ;
OP_COMMA         = ','         ;
OP_ASSIGN        = '='         ;      

OP_PERIOD        = '.'         ;
OP_MODULE_ACCESS = "::"        ;

OP_LOGICAL_NOT   = '!' | "not" ;
OP_EQUALITY      = "=="        ;
OP_NOT_EQUAL     = "!="        ;
OP_LESS_THAN     = '<'         ;
OP_GREATER_THAN  = '>'         ;
OP_LESS_EQUAL    = "<="        ;
OP_GREATER_EQUAL = ">="        ;

OP_LOGICAL_AND   = "and"       ;
OP_LOGICAL_OR    = "or"        ;

OP_ARROW         = "->"        ;

OP_EXPLICIT_REF  = '&'         ;
OP_EXPLICIT_COPY = '$'         ;
OP_EXPLICIT_MOVE = '~'         ;

OP_PAREN_L       = '('         ;
OP_PAREN_R       = ')'         ;
OP_BRACE_L       = '{'         ;
OP_BRACE_R       = '}'         ;
OP_BRACKET_L     = '['         ;
OP_BRACKET_R     = ']'         ;


(* parser rules *)

module = function+ EOF ;

number = INT | FLOAT ;

op_arithmetic = OP_PLUS | OP_MINUS | OP_ASTERISK | OP_FWDSLASH ;

type = ID
     | KW_I8 
     | KW_I16
     | KW_I32
     | KW_I64
     | KW_I128
     | KW_U8 
     | KW_U16
     | KW_U32
     | KW_U64
     | KW_U128
     | KW_F32
     | KW_F64
     | KW_BYTE
     | KW_CHAR
     | KW_STRING
     | KW_BOOL
     | KW_VOID
     ;

annotation = OP_COLON type ;

qualifier = KW_MUT ;

scope = BRACE_L statement* BRACE_R ;

param = ID qualifier? annotation ;

param_list = PAREN_L ((param,)* param)? PAREN_R ;

association = OP_ARROW type ;

function = qualifier? KW_FN ID param_list annotation? association? scope ;

arg_list = PAREN_L ((expr,)* expr)? PAREN_R ;

function_call = ID arg_list ;

expr = ID
     | number
     | function_call
     | expr op_arithmetic expr
;

decl = qualifier? KW_DATA ID annotation? ;

init = decl OP_ASSIGN expr ;

assignment = ID OP_ASSIGN expr ;

statement = expr
          | decl
          | init
          | assignment
;