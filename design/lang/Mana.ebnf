ID         = [a-zA-Z_][a-zA-Z0-9_]*  ; (*letter or underscore followed by any letters, numbers or underscores *)
INT        = [0-9]+                  ;
FLOAT      = INT.[0-9]+              ;
STRING     = "\"(?:[^\"\\]|\\.)*\""  ; (* anything between double-quoted strings, minus escape sequences *)
STRING_CH  = "'(?:[^'\\]|\\.)*'"     ; (* same but single quotes *)

KW_DATA   = "data"   ;
KW_MUT    = "mut"    ;
KW_IF     = "if"     ;
KW_ELSE   = "else"   ;
KW_RETURN = "return" ;

KW_LOOP      = "loop"  ;
KW_SKIP      = "skip"  ;
KW_BREAK     = "break" ;
OP_RANGE     = ".."    ;
OP_BINDING   = "=>"    ;

KW_FN     = "fn" ;
OP_RETURN = "->" ;

TERMINATOR = "\n" | ";";

(* parse rules *)
artifact = decl* EOF ;

decl = fn_decl
     | data_decl TERMINATOR
     ;

stmt   = decl
       | if_block 
       | loop 
       | (return | loop_control | assign | expr) TERMINATOR ;

scope  = '{' stmt* '}' ;

fn_decl = KW_FN ID param_list ret_type? scope   ;
param_list = '(' (param (',' param)*)? ')'      ;
param = ID type_spec?                           ;
ret_type = OP_RETURN ID                         ;

return = KW_RETURN expr? ;

data_decl   = KW_MUT? KW_DATA ID type_spec? ('=' expr)? ;
type_spec   = (':' ID) ;

if_condition = KW_IF expr  ;

if_block = if_condition scope if_tail? ;
if_tail = KW_ELSE (if_block | scope)   ;

loop = KW_LOOP (ID ':')? loop_body ;

loop_body = scope (OP_BINDING if_condition)?                  (* infinite / post-conditional *)
          | if_condition scope                                (* conditional *)
          | expr scope                                        (* fixed *)
          | expr (OP_RANGE expr)? OP_BINDING mut? ID scope    (* ranged *)   
          ;

loop_control = (KW_SKIP | KW_BREAK) (OP_BINDING ID)? if_condition? ;

assign = ID '=' expr   ;   

(* Todo: still need to bake associativity into the grammar *)
(* e.g. logical = equality | logical ('&&' | '||') equality *)
(* also need to give AND higher precedence than OR *)
expr       = logical                                  ;  
logical    = equality ( ('&&' | '||') equality )*     ;
equality   = comparison (  ('!=' | '==') comparison)* ;
comparison = term ( ('>' | '>=' | '<' | '<=') term)*  ;
term       = factor ( ('-' | '+') factor)*            ;
factor     = unary ( ('/' | '*') unary )*             ;
unary      = ('!' | '-') unary | list_access          ;
list_access = primary ('[' expr ']')?                 ;

primary    = invocation 
           | grouping 
           | literal 
           | array_literal 
           | ID  
           ;

grouping   = '(' expr ')' ;
literal    = number
           | string
           | 'true'
           | 'false'
           | 'none'
           ;

array_literal = '[' elem_list? ']'   ;
elem_list = expr (',' expr)* (',')?  ;

number = INT | FLOAT        ;
string = STRING | STRING_CH ;
