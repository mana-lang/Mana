type Foo {
	a: f64
	b: fn(f64, string) -> i16
	c: string
}

fn Bar(a: f64, b: string) -> i16 {
	fmt.Print("{a} | {b}")
}

data foo: Foo = {.a = 95.4, .b = Bar, .c = "hey"}

foo.b(22.7, foo.c) // identical to Bar(22.7, "hey")

fn Invoke(baz: fn(f64, string) -> i16, a: f64, b: string) {
	baz(a, b)
}

Invoke(foo.b, foo.a, foo.c)
Invoke(Bar, 95.4, "hey")

fn Blep() {
	data x = 32
	fn Closure(): x -> i32 {
		fmt.PrintLine("{x}")
	}
	
	Closure()
}

@[Pure, Inline]
fn Sqrt(v: i32) {
	return v * v
}

const fn Pi() -> f64 {
	return 3.14159265358979
}
const fn ToRadians(degrees: f64) -> f64 {
	return degrees * Pi() / 180
}

type Invocator {
	a: i32
	b: string
}

interface for type Invocator {
	operator () => mut fn(x: i32) -> i32 {
		.a += x
		return .a
	}
}
